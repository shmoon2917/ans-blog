---
title: 스타트업 생존기
date: '2022-03-04 17:43:03'
description: 파도에 휩쓸릴 것인가, 탈 것인가
---

![thumbnail {653x265}](/assets/articles/react-thumbnail.png 'This is a thumbnail')

> [The Lifecycle of React Hooks Component](https://blog.bhanuteja.dev/the-lifecycle-of-react-hooks-component) 글의 내용을 번역한 것입니다.

# Mount

이 단계는 컴포넌트가 처음으로 페이지에 마운트되는 단계입니다. 이 단계에서 <a href="https://moonerd.dev" target="_blank">hook</a> 의 흐름은 다음과 같습니다.

## Lazy initializers 실행

1. JavaScript Interface(JSI)
   1. k
   2. c
2. Fabric
   - articles
   - b

- Turbo Modules
- CodeGen

useState에 직접적인 값 대신에 넘겨지는 함수를 게으른 초기화(lazy initializaers) 라고 합니다. 게으른 초기화 함수는 오직 첫 마운트 단계에서만 실행되고, 이 후에 다시 리렌더링이 된다면 이 함수의 실행은 무시됩니다.
렌더링

---

```ts
import React from "react";

function Child() {
  console.log("Child: render start");

  const [count, setCount] = React.useState(() => {
    console.log("Child: useState(() => 0)");
    return 0;
  });

  console.log(`Child: count = ${count}`);

  React.useEffect(() => {
    console.log("Child: useEffect(() => {})");
    return () => {
      console.log("Child: useEffect(() => {}) cleanup");
    };
  });

  React.useEffect(() => {
    console.log("Child: useEffect(() => {}, [])");
    return () => {
      console.log("Child: useEffect(() => {}, []) cleanup");
    };
  }, []);

  React.useEffect(() => {
    console.log("Child: useEffect(() => {}, [count])");
    return () => {
      console.log("Child: useEffect(() => {}, [count]) cleanup");
    };
  }, [count]);

  const element = (
    <button onClick={() => setCount((previousCount) => previousCount + 1)}>
      {count}
    </button>
  );
```

컴포넌트 함수 자체를 호출하는 과정입니다. e.g. App(props)
모든 useState hook과 다른 값들이 표현되는 때입니다.
이름이 렌더링이긴 하지만, 이 시점에서 DOM이 변경되지는 않습니다.
리액트의 DOM 업데이트

DOM을 업데이트하는 것은 브라우저가 스크린을 그리는 것과는 다릅니다.
Layout Effects 실행

다음 글에서 layout effect에 대해 다룰 것입니다.
브라우저의 스크린 그리기

Effects 실행

Update
이 단계는 컴포넌트가 업데이트되는 단계입니다. 이 업데이트는 다음과 같은 이유들로 발생합니다:

부모 컴포넌트의 재렌더링
컴포넌트 State 변경
Context 변경
이 단계에서 hook의 흐름은 다음과 같습니다.

렌더링

리액트의 DOM 업데이트

Layout Effects Cleanup 실행

useLayoutEffect도 useEffect처럼 클린업 단계가 존재합니다.
Layout Effects 실행

브라우저의 스크린 그리기

Effects Cleanup 실행

Effects 실행

보시다시피, 마운트 단계에서 과정과 유사하지만, Layout Effects와 Effects Cleanup이 실행된다는 것이 차이점입니다.

Unmount
이 단계는 컴포넌트가 페이지로부터 언마운트되는 단계입니다. 이 단계에서 hook의 흐름은 다음과 같습니다.

Layout Effects Cleanup 실행

Effects 실행

이 단계에서는 Cleanup만이 실행됩니다.
